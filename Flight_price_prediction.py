# -*- coding: utf-8 -*-
"""Bonus_project

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1s6We51whs8vZcE0703O7dRdkSGB3AvHx
"""

import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split as tts
from sklearn.metrics import r2_score as r2
import warnings
warnings.filterwarnings('ignore') 
import  seaborn as sns
from datetime import date

flight = pd.read_csv("data.csv")
flight

"""#Preprocessing and Visualization

##Dropping NA and Duplicate values
"""

flight.info()

"""Dropping the NA values"""

flight.isna().sum()

"""Dropping the Duplicate values"""

flight.duplicated().sum()

flight = flight.drop_duplicates()

flight = flight.dropna()

"""##Visualization and Encoding"""

plt.figure(figsize = (10,5))
sns.countplot(x='Airline' , data = flight).set_xticklabels(labels = (flight['Airline'].unique()).tolist() , rotation = 90)
plt.show()

"""As evident in the graph , the last four values are very less in number so I have encoded them into a single
value . This helped in increasing the performance of all the models significantly . The same process was followed for the columns
“Total_stops” and “Additional_info” 
"""

flight['Airline'] = flight['Airline'].replace(['IndiGo' , 'Air India' , 'Jet Airways' , 'SpiceJet' , 'Multiple carriers' , 'GoAir' , 'Vistara' , 'Air Asia' , 'Vistara Premium economy' , 'Jet Airways Business' , 'Multiple carriers Premium economy' , 'Trujet'] , [1,2,3,4 ,5,6,7,8,6,6,6,6])
flight['Airline'] = flight['Airline'].astype(int)

plt.figure(figsize = (10,5))
sns.countplot(x='Source' , data = flight).set_xticklabels(labels = (flight['Source'].unique()).tolist() , rotation = 90)
plt.show()

plt.figure(figsize = (10,5))
sns.countplot(x='Destination' , data = flight).set_xticklabels(labels = (flight['Destination'].unique()).tolist() , rotation = 90)
plt.show()

plt.figure(figsize = (10,5))
sns.countplot(x='Total_Stops' , data = flight).set_xticklabels(labels = (flight['Total_Stops'].unique()).tolist() , rotation = 90)
plt.show()

flight['Total_Stops'] = flight['Total_Stops'].replace(['non-stop' , '1 stop' , '2 stops' , '3 stops' , '4 stops'] , [0,1,2,3,3])
flight['Total_Stops'] = flight['Total_Stops'].astype(int)

plt.figure(figsize = (10,5))
sns.countplot(x='Additional_Info' , data = flight).set_xticklabels(labels = (flight['Additional_Info'].unique()).tolist() , rotation = 90)
plt.show()

flight['Additional_Info'] = flight['Additional_Info'].replace(['No info', 'No Info' , 'In-flight meal not included' , 'No check-in baggage included' , '1 Short layover' , '1 Long layover' ,'Change airports' , 'Business class' ,  'Red-eye flight','2 Long layover'  ] , [0,0,1,2,3,3,3,3,3,3])
flight['Additional_Info'] = flight['Additional_Info'].astype(int)

np.unique(flight['Date_of_Journey'])

"""##Preprocessing of the column : Date of Journey

I have separated the Date of Journey into three different columns : year , month and Date . But the year column only has one value i.e. 2019 so I dropped that column .

Morever I created a new column called Day which contains the information of the day for the corresponding date . This is because the flight prices are usually higher on the weekends so it will good for the training the model . 1 stands for Monday , 2 stands for Tuesday and so on ....
"""

s = '01/03/2019'
a = s.split("/")
d  =int(a[0])
m = int(a[1])
y = int(a[2])
date(y , m , d).weekday()

day = []
for DATE in flight['Date_of_Journey']:
  a = DATE.split("/")
  d  =int(a[0])
  m = int(a[1])
  y = int(a[2])
  day.append(date(y , m , d).weekday() + 1)
flight['Day'] = day

print("Average price of Flight tickets on Sunday : " , flight[flight['Day'] == 7]['Price'].mean())
print("Average price of Flight tickets on Monday : " , flight[flight['Day'] == 1]['Price'].mean())

"""So creating the Weekday column was a good choice as cleary the average price of tickets is much higher on weekend than on weekdays"""

Date = []
month = []
year = []
for date in flight['Date_of_Journey']:
  info = date.split("/")
  if(info[0][0] == '0'):
    Date.append(int(info[0][1]))
  else:
    Date.append(int(info[0]))
  month.append(int(info[1][1]))
  year.append(int(info[2]))
flight['Date'] = Date
flight['Month'] = month
flight['Year'] = year
flight = flight.drop(columns = 'Date_of_Journey')

np.unique(flight['Month'])

np.unique(flight['Date'])

np.unique(flight['Year'])

"""Dropping the Year columns as there is only one value here"""

flight = flight.drop(columns = 'Year')

"""##Preprocessing of the column : Departure Time

I have seperated the Departure Time into the hour and minutes columns so it is easier to visualize
"""

dept_min = []
dept_hour = []
for time in flight['Dep_Time']:
  time = time.split(" ")[0]
  time = time.split(":")
  dept_min.append(int(time[1]))
  dept_hour.append(int(time[0]))
flight['Dept_Min'] = dept_min
flight['Dept_Hour'] = dept_hour
flight = flight.drop(columns = "Dep_Time")

"""##Preprocessing of the column : Arrival Time

I have seperated the Arrival Time into the hour and minutes columns so it is easier to visualize
"""

arr_min = []
arr_hour = []
for time in flight['Arrival_Time']:
  time = time.split(" ")[0]
  time = time.split(":")
  arr_min.append(int(time[1]))
  arr_hour.append(int(time[0]))
flight['Arrival_Min'] = arr_min
flight['Arrival_Hour'] = arr_hour
flight = flight.drop(columns = "Arrival_Time")

"""##Preprocessing of the column : Duration

I converted the Duration column into Duration in minutes because some flights were less than an hour and overall the duration of flight is a really important factor in the price of the flight
"""

duration = []
for dur in flight['Duration']:
  dur = dur.split(" ")
  if dur[0][1] == 'm':
    time = int(dur[0][0])
  else:
    hour = int(dur[0].split("h")[0])
    if len(dur) != 1 :
      min = int(dur[1].split("m")[0])
      time = hour*60 + min
    else:
      time = hour  
  duration.append(int(time))
flight['Duration'] = duration

"""##Preprocessing of the column : Route

The Route column is very important and it can't be ignored . There are at most 6 cities in the route column . I have seperated the route column into 4 columns with First city , Second City ..... Fourth City since the Source and Destination are already present . If the route contains only 3 cities then only the First city column is filled and the rest are filled with 'None' value . These columns will then be label encoded
"""

city1 = []
city2 = []
city3 = []
city4 = []
for i in flight['Route']:
  arr = i.split(" →")
  b = arr[1:-1]
  if(len(b) == 0):
    city1.append("None")
    city2.append("None")
    city3.append("None")
    city4.append("None")
  elif(len(b) == 1):
    city1.append(b[0])
    city2.append("None")
    city3.append("None")
    city4.append("None")
  elif(len(b) == 2):
    city1.append(b[0])
    city2.append(b[1])
    city3.append("None")
    city4.append("None")
  elif(len(b) == 3):
    city1.append(b[0])
    city2.append(b[1])
    city3.append(b[2])
    city4.append("None")
  elif(len(b) == 4):
    city1.append(b[0])
    city2.append(b[1])
    city3.append(b[2])
    city4.append(b[3])
flight['First_stop'] = city1
flight['Second_stop'] = city2
flight['Third_stop'] = city3
flight['Fourth_stop'] = city4
flight = flight.drop(columns = "Route")

flight

plt.figure(figsize = (15,15))
sns.heatmap(flight.corr(), annot = True, cmap = "RdYlGn")
plt.show()

flight

"""##Encoding the Categorical Columns"""

print(np.unique(flight['First_stop']))
print(np.unique(flight['Second_stop']))
print(np.unique(flight['Third_stop']))
print(np.unique(flight['Fourth_stop']))

le = LabelEncoder()
categorical_columns = [ 'Source' , 'Destination' , 'First_stop' , 'Second_stop' , 'Third_stop' , 'Fourth_stop']
for col in categorical_columns:
  flight[col] = le.fit_transform(flight[col])

"""This completes the preprocessing of the data . Now the dataset looks like this"""

flight

X = flight.drop(columns = 'Price')
y = flight.Price
x_train , x_test , y_train , y_test = tts(X, y, test_size = 0.2 , shuffle = True , random_state = 1)

"""#Implementing Different Models"""

from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn import svm
from sklearn.neighbors import KNeighborsRegressor
import xgboost as xgb
import lightgbm as lgb
from sklearn import linear_model
from sklearn.ensemble import ExtraTreesRegressor

model = []
model.append(RandomForestRegressor())
model.append(svm.SVR(kernel = 'rbf'))
model.append(ExtraTreesRegressor())
model.append(LinearRegression())
model.append(DecisionTreeRegressor())
model.append(xgb.XGBRegressor(objective='reg:squarederror'))
model.append(lgb.LGBMRegressor())
model.append(KNeighborsRegressor())

!pip install tabulate
from tabulate import tabulate
from sklearn.model_selection import cross_val_score as cv

table = [["Model" , "Training R2 score" , "Testing R2 score" , "Cross Val 1", "Cross Val 2", "Cross Val 3", "Cross Val 4", "Cross Val 5"]]
k = 0
for reg in model:
  cross_val = cv(reg , x_train , y_train , scoring = 'r2')
  reg.fit(x_train , y_train)
  ind_reg = [reg , r2(y_train , reg.predict(x_train)) ,  r2(y_test , reg.predict(x_test)) ]
  for i in cross_val:
    ind_reg.append(i)
  table.append(ind_reg)

print(tabulate(table ,headers = 'firstrow' ,  tablefmt='fancy_grid'))

"""#Tuning the best model : RandomForestRegressor"""

from sklearn.model_selection import RandomizedSearchCV
from datetime import time
from sklearn.metrics import mean_absolute_error as mae
from sklearn.metrics import mean_squared_error as mse

param_dist = {
'n_estimators': list(range(100, 1000, 10)),
'min_samples_leaf': list(range(1, 25)),
'max_depth': list(range(2, 20)),
'max_features': ['auto', 'sqrt'],
'bootstrap': [True, False]}

rfc = RandomForestRegressor()
n_iter = 50
model_random_search = RandomizedSearchCV(
estimator=rfc,
param_distributions=param_dist,
n_iter=n_iter)

model_random_search.fit(x_train, y_train)

model_random_search.best_params_

rfc = model_random_search.best_estimator_
rfc.fit(x_train , y_train)
table = [['Data' , 'R2 score' , 'MSE' , 'MAE']]
table.append(["Training" , r2(y_train , rfc.predict(x_train)) , mse(y_train , rfc.predict(x_train)) , mae(y_train , rfc.predict(x_train))])
table.append(["Testing" , r2(y_test , rfc.predict(x_test)) , mse(y_test , rfc.predict(x_test)) , mae(y_test , rfc.predict(x_test))])
print(tabulate(table ,headers = 'firstrow' ,  tablefmt='fancy_grid'))

"""#Implementing the Pipeline"""

from sklearn.base import BaseEstimator

from sklearn.base import TransformerMixin
class preprocess(BaseEstimator , TransformerMixin):
  def __init__(self):
    print("init() function called")

  def fit(self , X , y = None):
    print("fit() function called")
    return self
  def transform(self , X , y = None):
    from datetime import date
    print("transform() function called")
    X['Airline'] = X['Airline'].replace(['IndiGo' , 'Air India' , 'Jet Airways' , 'SpiceJet' , 'Multiple carriers' , 'GoAir' , 'Vistara' , 'Air Asia' , 'Vistara Premium economy' , 'Jet Airways Business' , 'Multiple carriers Premium economy' , 'Trujet'] , [1,2,3,4 ,5,6,7,8,6,6,6,6])
    X['Airline'] = X['Airline'].astype(int)
    X['Total_Stops'] = X['Total_Stops'].replace(['non-stop' , '1 stop' , '2 stops' , '3 stops' , '4 stops'] , [0,1,2,3,3])
    X['Total_Stops'] = X['Total_Stops'].astype(int)
    X['Additional_Info'] = X['Additional_Info'].replace(['No info', 'No Info' , 'In-flight meal not included' , 'No check-in baggage included' , '1 Short layover' , '1 Long layover' ,'Change airports' , 'Business class' ,  'Red-eye flight','2 Long layover'  ] , [0,0,1,2,3,3,3,3,3,3])
    X['Additional_Info'] = X['Additional_Info'].astype(int)

    day = []
    for DATE in X['Date_of_Journey']:
      a = DATE.split("/")
      d  =int(a[0])
      m = int(a[1])
      y = int(a[2])
      day.append(date(y , m , d).weekday() + 1)
    X['Day'] = day

    Date = []
    month = []
    year = []
    for date in X['Date_of_Journey']:
      info = date.split("/")
      if(info[0][0] == '0'):
        Date.append(int(info[0][1]))
      else:
        Date.append(int(info[0]))
      month.append(int(info[1][1]))
      year.append(int(info[2]))
    X['Date'] = Date
    X['Month'] = month
    X = X.drop(columns = 'Date_of_Journey')

    dept_min = []
    dept_hour = []
    for time in X['Dep_Time']:
      time = time.split(" ")[0]
      time = time.split(":")
      dept_min.append(int(time[1]))
      dept_hour.append(int(time[0]))
    X['Dept_Min'] = dept_min
    X['Dept_Hour'] = dept_hour
    X = X.drop(columns = "Dep_Time")

    arr_min = []
    arr_hour = []
    for time in X['Arrival_Time']:
      time = time.split(" ")[0]
      time = time.split(":")
      arr_min.append(int(time[1]))
      arr_hour.append(int(time[0]))
    X['Arrival_Min'] = arr_min
    X['Arrival_Hour'] = arr_hour
    X = X.drop(columns = "Arrival_Time")

    duration = []
    for dur in X['Duration']:
      dur = dur.split(" ")
      if dur[0][1] == 'm':
        time = int(dur[0][0])
      else:
        hour = int(dur[0].split("h")[0])
        if len(dur) != 1 :
          min = int(dur[1].split("m")[0])
          time = hour*60 + min
        else:
          time = hour  
      duration.append(int(time))
    X['Duration'] = duration

    city1 = []
    city2 = []
    city3 = []
    city4 = []
    for i in X['Route']:
      arr = i.split(" →")
      b = arr[1:-1]
      if(len(b) == 0):
        city1.append("None")
        city2.append("None")
        city3.append("None")
        city4.append("None")
      elif(len(b) == 1):
        city1.append(b[0])
        city2.append("None")
        city3.append("None")
        city4.append("None")
      elif(len(b) == 2):
        city1.append(b[0])
        city2.append(b[1])
        city3.append("None")
        city4.append("None")
      elif(len(b) == 3):
        city1.append(b[0])
        city2.append(b[1])
        city3.append(b[2])
        city4.append("None")
      elif(len(b) == 4):
        city1.append(b[0])
        city2.append(b[1])
        city3.append(b[2])
        city4.append(b[3])
    X['First_stop'] = city1
    X['Second_stop'] = city2
    X['Third_stop'] = city3
    X['Fourth_stop'] = city4
    X = X.drop(columns = "Route")


    le = LabelEncoder()
    categorical_columns = [ 'Source' , 'Destination' , 'First_stop' , 'Second_stop' , 'Third_stop' , 'Fourth_stop']
    for col in categorical_columns:
      X[col] = X[col].replace(np.unique(X[col]) , list(range(1,len(np.unique(X[col])) + 1)))
    return X

from sklearn.pipeline import Pipeline
pipe = Pipeline(steps = [
                         ("preprocess" , preprocess()),
                         ("regressor" , rfc)
])

new_data = pd.read_csv("/content/data.csv")
new_data = new_data.dropna()
x_train_new , x_test_new , y_train_new , y_test_new = tts(new_data.drop(columns = 'Price') , new_data.Price , test_size = 0.2 , shuffle = True , random_state = 1)
pipe.fit(x_train_new , y_train_new)

y_pred_new = pipe.predict(x_test_new)
print("Predicted values from pipeline :")
print(y_pred_new)